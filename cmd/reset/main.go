// Package main реализует генератор методов Reset() для структур.
//
// Утилита сканирует все пакеты проекта, находит структуры с комментарием
// generate:reset и генерирует для них методы Reset(), которые сбрасывают
// состояние структуры к начальным значениям.
//
// Использование:
//
//	go run ./cmd/reset/main.go
//
// Для каждого пакета со структурами создаётся файл reset.gen.go.
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

// generateComment — маркер комментария для генерации метода Reset().
const generateComment = "generate:reset"

// structInfo содержит информацию о структуре для генерации метода Reset().
//
// name — имя структуры.
// fields — список полей структуры.
// structType — AST-узел структуры.
type structInfo struct {
	name       string
	fields     []*ast.Field
	structType *ast.StructType
}

// "BURN_BABY_BURN" - Apollo 11.
func main() {
	if err := run(); err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

type (
	// Scanner сканирует директории в поисках .go файлов.
	Scanner interface {
		Scan(rootDir string) ([]string, error)
	}

	// Parser парсит файлы и извлекает информацию о структурах.
	Parser interface {
		Parse(filePath string) ([]structInfo, error)
	}

	// Generator генерирует код для структур.
	Generator interface {
		Generate(pkgDir string, structs []structInfo) error
	}
)

// fileScanner реализует Scanner для поиска .go файлов.
type fileScanner struct{}

func (s *fileScanner) Scan(rootDir string) ([]string, error) {
	var files []string

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Пропускаем директории vendor, .git.
		if info.IsDir() {
			if info.Name() == "vendor" || info.Name() == ".git" {
				return filepath.SkipDir
			}
			return nil
		}

		// Обрабатываем только .go файлы (кроме сгенерированных).
		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, ".gen.go") {
			return nil
		}

		files = append(files, path)
		return nil
	})

	return files, err
}

// resetParser реализует Parser для поиска структур с комментарием generate:reset.
type resetParser struct{}

// Parse находит все структуры в файле с комментарием generate:reset.
func (p *resetParser) Parse(filePath string) ([]structInfo, error) {
	// Парсим файл.
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var structs []structInfo

	// Создаём карту комментариев для связывания их с объявлениями.
	cmap := ast.NewCommentMap(fset, node, node.Comments)

	ast.Inspect(node, func(n ast.Node) bool {
		// Ищем общие объявления.
		genDecl, ok := n.(*ast.GenDecl)
		if !ok {
			return true
		}

		// Проверяем комментарии, связанные с объявлением.
		hasResetComment := false
		if genDecl.Doc != nil {
			for _, comment := range genDecl.Doc.List {
				if strings.Contains(comment.Text, generateComment) {
					hasResetComment = true
					break
				}
			}
		}

		// Также проверяем комментарии из карты комментариев.
		if !hasResetComment {
			if comments := cmap[genDecl]; comments != nil {
				for _, commentGroup := range comments {
					for _, comment := range commentGroup.List {
						if strings.Contains(comment.Text, generateComment) {
							hasResetComment = true
							break
						}
					}
					if hasResetComment {
						break
					}
				}
			}
		}

		if !hasResetComment {
			return true
		}

		// Ищем спецификации типов внутри объявления.
		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// Проверяем, что это структура.
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			structs = append(structs, structInfo{
				name:       typeSpec.Name.Name,
				fields:     structType.Fields.List,
				structType: structType,
			})
		}

		return true
	})

	return structs, nil
}

// resetGenerator реализует Generator для создания файлов reset.gen.go.
type resetGenerator struct{}

// Generate генерирует файл reset.gen.go с методами Reset() для структур пакета.
func (g *resetGenerator) Generate(pkgDir string, structs []structInfo) error {
	// Получаем имя пакета из существующих файлов.
	pkgName, err := g.getPackageName(pkgDir)
	if err != nil {
		return err
	}

	// Собираем необходимые импорты.
	imports := make(map[string]bool)
	for _, s := range structs {
		g.collectImports(s.fields, imports)
	}

	var buf bytes.Buffer

	// Записываем заголовок файла.
	buf.WriteString("// Code generated by cmd/reset. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))

	// Записываем импорты, если они нужны.
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for imp := range imports {
			buf.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	// Генерируем метод Reset() для каждой структуры.
	for _, s := range structs {
		buf.WriteString(g.generateResetMethod(s))
		buf.WriteString("\n")
	}

	// Форматируем сгенерированный код.
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Если форматирование не удалось, выводим неформатированный код для отладки.
		return fmt.Errorf("failed to format generated code: %w\nUnformatted code:\n%s", err, buf.String())
	}

	// Записываем в файл
	outputPath := filepath.Join(pkgDir, "reset.gen.go")
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// collectImports собирает импорты, необходимые для полей структуры.
func (g *resetGenerator) collectImports(fields []*ast.Field, imports map[string]bool) {
	for _, field := range fields {
		g.collectImportsFromType(field.Type, imports)
	}
}

// collectImportsFromType рекурсивно собирает импорты из AST-узла типа.
func (g *resetGenerator) collectImportsFromType(expr ast.Expr, imports map[string]bool) {
	switch t := expr.(type) {
	case *ast.SelectorExpr:
		// Квалифицированный идентификатор вроде time.Time.
		if ident, ok := t.X.(*ast.Ident); ok {
			// Распространённые имена пакетов — сопоставляем с полными путями импорта.
			switch ident.Name {
			case "time":
				imports["time"] = true
			case "context":
				imports["context"] = true
			case "sync":
				imports["sync"] = true
			}
		}
	case *ast.StarExpr:
		g.collectImportsFromType(t.X, imports)
	case *ast.ArrayType:
		g.collectImportsFromType(t.Elt, imports)
	case *ast.MapType:
		g.collectImportsFromType(t.Key, imports)
		g.collectImportsFromType(t.Value, imports)
	case *ast.ChanType:
		g.collectImportsFromType(t.Value, imports)
	}
}

// getPackageName получает имя пакета из директории.
func (g *resetGenerator) getPackageName(dir string) (string, error) {
	// Ищем .go файлы в директории (исключая тесты и сгенерированные).
	pattern := filepath.Join(dir, "*.go")
	files, err := filepath.Glob(pattern)
	if err != nil {
		return "", err
	}

	// Парсим первый подходящий файл для получения имени пакета.
	fset := token.NewFileSet()
	for _, file := range files {
		// Пропускаем тестовые и сгенерированные файлы.
		if strings.HasSuffix(file, "_test.go") || strings.HasSuffix(file, ".gen.go") {
			continue
		}

		node, err := parser.ParseFile(fset, file, nil, parser.PackageClauseOnly)
		if err != nil {
			continue
		}

		if node.Name != nil {
			return node.Name.Name, nil
		}
	}

	return "", fmt.Errorf("no package found in directory %s", dir)
}

// generateResetMethod генерирует текст метода Reset() для структуры.
func (g *resetGenerator) generateResetMethod(s structInfo) string {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("func (r *%s) Reset() {\n", s.name))
	buf.WriteString("\tif r == nil {\n")
	buf.WriteString("\t\treturn\n")
	buf.WriteString("\t}\n\n")

	// Генерируем код сброса для каждого поля.
	for _, field := range s.fields {
		if len(field.Names) == 0 {
			// Встроенное поле — пропускаем.
			continue
		}

		for _, fieldName := range field.Names {
			resetCode := g.generateFieldReset(fieldName.Name, field.Type)
			buf.WriteString(resetCode)
		}
	}

	buf.WriteString("}\n")

	return buf.String()
}

// generateFieldReset генерирует код сброса для отдельного поля структуры.
func (g *resetGenerator) generateFieldReset(fieldName string, fieldType ast.Expr) string {
	switch t := fieldType.(type) {
	case *ast.Ident:
		return g.resetIdentType(fieldName, t)
	case *ast.StarExpr:
		return g.resetPointerType(fieldName, t)
	case *ast.ArrayType:
		return g.resetArrayType(fieldName, t)
	case *ast.MapType:
		return g.resetMapType(fieldName)
	case *ast.ChanType:
		return g.resetChanType()
	case *ast.InterfaceType:
		return g.resetInterfaceType(fieldName)
	case *ast.SelectorExpr:
		return g.resetSelectorType(fieldName, t)
	case *ast.StructType:
		return g.resetStructType(fieldName)
	default:
		return g.resetDefaultType(fieldName)
	}
}

// resetIdentType обрабатывает примитивные типы и именованные типы.
func (g *resetGenerator) resetIdentType(fieldName string, t *ast.Ident) string {
	resetValue := getZeroValue(t.Name)
	if resetValue != "" {
		return fmt.Sprintf("\tr.%s = %s\n", fieldName, resetValue)
	}
	// Может быть структурой с методом Reset().
	return fmt.Sprintf("\tif resetter, ok := interface{}(&r.%s).(interface{ Reset() }); ok {\n"+
		"\t\tresetter.Reset()\n"+
		"\t}\n", fieldName)
}

// resetPointerType обрабатывает указатели.
func (g *resetGenerator) resetPointerType(fieldName string, t *ast.StarExpr) string {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("\tif r.%s != nil {\n", fieldName))

	switch elem := t.X.(type) {
	case *ast.Ident:
		buf.WriteString(g.resetPointerToIdent(fieldName, elem))
	case *ast.SelectorExpr:
		buf.WriteString(g.resetPointerToSelector(fieldName, elem))
	case *ast.StructType:
		buf.WriteString(g.resetPointerToStruct(fieldName))
	default:
		buf.WriteString(g.resetPointerToOther(fieldName))
	}

	buf.WriteString("\t}\n")
	return buf.String()
}

// resetPointerToIdent обрабатывает указатель на именованный тип.
func (g *resetGenerator) resetPointerToIdent(fieldName string, elem *ast.Ident) string {
	resetValue := getZeroValue(elem.Name)
	if resetValue != "" {
		return fmt.Sprintf("\t\t*r.%s = %s\n", fieldName, resetValue)
	}
	// Указатель на структуру — пытаемся вызвать Reset().
	return fmt.Sprintf("\t\tif resetter, ok := interface{}(r.%s).(interface{ Reset() }); ok {\n"+
		"\t\t\tresetter.Reset()\n"+
		"\t\t}\n", fieldName)
}

// resetPointerToSelector обрабатывает указатель на квалифицированный тип (например, *time.Time).
func (g *resetGenerator) resetPointerToSelector(fieldName string, elem *ast.SelectorExpr) string {
	return fmt.Sprintf("\t\tif resetter, ok := interface{}(r.%s).(interface{ Reset() }); ok {\n"+
		"\t\t\tresetter.Reset()\n"+
		"\t\t} else {\n"+
		"\t\t\t*r.%s = %s{}\n"+
		"\t\t}\n", fieldName, fieldName, formatType(elem))
}

// resetPointerToStruct обрабатывает указатель на анонимную структуру.
func (g *resetGenerator) resetPointerToStruct(fieldName string) string {
	return fmt.Sprintf("\t\tif resetter, ok := interface{}(r.%s).(interface{ Reset() }); ok {\n"+
		"\t\t\tresetter.Reset()\n"+
		"\t\t}\n", fieldName)
}

// resetPointerToOther обрабатывает прочие типы указателей.
func (g *resetGenerator) resetPointerToOther(fieldName string) string {
	return fmt.Sprintf("\t\tif resetter, ok := interface{}(r.%s).(interface{ Reset() }); ok {\n"+
		"\t\t\tresetter.Reset()\n"+
		"\t\t}\n", fieldName)
}

// resetArrayType обрабатывает массивы и слайсы.
func (g *resetGenerator) resetArrayType(fieldName string, t *ast.ArrayType) string {
	if t.Len == nil {
		// Слайс - просто обрезаем до нулевой длины.
		return fmt.Sprintf("\tr.%s = r.%s[:0]\n", fieldName, fieldName)
	}
	// Массив - сбрасываем каждый элемент.
	return g.resetArrayElements(fieldName, t)
}

// resetArrayElements сбрасывает элементы массива.
func (g *resetGenerator) resetArrayElements(fieldName string, t *ast.ArrayType) string {
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("\tfor i := range r.%s {\n", fieldName))

	switch elem := t.Elt.(type) {
	case *ast.Ident:
		buf.WriteString(g.resetArrayIdentElement(fieldName, elem))
	case *ast.StarExpr:
		buf.WriteString(g.resetArrayPointerElement(fieldName))
	default:
		buf.WriteString(g.resetArrayDefaultElement(fieldName))
	}

	buf.WriteString("\t}\n")
	return buf.String()
}

// resetArrayIdentElement сбрасывает элемент массива примитивного типа.
func (g *resetGenerator) resetArrayIdentElement(fieldName string, elem *ast.Ident) string {
	resetValue := getZeroValue(elem.Name)
	if resetValue != "" {
		return fmt.Sprintf("\t\tr.%s[i] = %s\n", fieldName, resetValue)
	}
	return fmt.Sprintf("\t\tif resetter, ok := interface{}(&r.%s[i]).(interface{ Reset() }); ok {\n"+
		"\t\t\tresetter.Reset()\n"+
		"\t\t}\n", fieldName)
}

// resetArrayPointerElement сбрасывает элемент массива-указателя.
func (g *resetGenerator) resetArrayPointerElement(fieldName string) string {
	return fmt.Sprintf("\t\tif r.%s[i] != nil {\n"+
		"\t\t\tif resetter, ok := interface{}(r.%s[i]).(interface{ Reset() }); ok {\n"+
		"\t\t\t\tresetter.Reset()\n"+
		"\t\t\t}\n"+
		"\t\t}\n", fieldName, fieldName)
}

// resetArrayDefaultElement сбрасывает элемент массива другого типа.
func (g *resetGenerator) resetArrayDefaultElement(fieldName string) string {
	return fmt.Sprintf("\t\tif resetter, ok := interface{}(&r.%s[i]).(interface{ Reset() }); ok {\n"+
		"\t\t\tresetter.Reset()\n"+
		"\t\t}\n", fieldName)
}

// resetMapType обрабатывает мапы.
func (g *resetGenerator) resetMapType(fieldName string) string {
	return fmt.Sprintf("\tclear(r.%s)\n", fieldName)
}

// resetChanType обрабатывает каналы (не сбрасываются).
func (g *resetGenerator) resetChanType() string {
	// Канал — не можем по-настоящему сбросить, оставляем как есть.
	return ""
}

// resetInterfaceType обрабатывает интерфейсы.
func (g *resetGenerator) resetInterfaceType(fieldName string) string {
	return fmt.Sprintf("\tif resetter, ok := r.%s.(interface{ Reset() }); ok && r.%s != nil {\n"+
		"\t\tresetter.Reset()\n"+
		"\t}\n", fieldName, fieldName)
}

// resetSelectorType обрабатывает квалифицированные типы.
func (g *resetGenerator) resetSelectorType(fieldName string, t *ast.SelectorExpr) string {
	return fmt.Sprintf("\tif resetter, ok := interface{}(&r.%s).(interface{ Reset() }); ok {\n"+
		"\t\tresetter.Reset()\n"+
		"\t} else {\n"+
		"\t\tr.%s = %s{}\n"+
		"\t}\n", fieldName, fieldName, formatType(t))
}

// resetStructType обрабатывает анонимные структуры.
func (g *resetGenerator) resetStructType(fieldName string) string {
	return fmt.Sprintf("\tif resetter, ok := interface{}(&r.%s).(interface{ Reset() }); ok {\n"+
		"\t\tresetter.Reset()\n"+
		"\t}\n", fieldName)
}

// resetDefaultType обрабатывает прочие типы.
func (g *resetGenerator) resetDefaultType(fieldName string) string {
	return fmt.Sprintf("\tif resetter, ok := interface{}(&r.%s).(interface{ Reset() }); ok {\n"+
		"\t\tresetter.Reset()\n"+
		"\t}\n", fieldName)
}

func run() error {
	scanner := &fileScanner{}
	structParser := &resetParser{}
	generator := &resetGenerator{}

	// Сканируем файлы.
	files, err := scanner.Scan(".")
	if err != nil {
		return fmt.Errorf("failed to scan directory: %w", err)
	}

	// Парсим файлы и группируем структуры по пакетам.
	packagesToGenerate := make(map[string][]structInfo)

	for _, file := range files {
		structs, err := structParser.Parse(file)
		if err != nil {
			return fmt.Errorf("failed to parse %s: %w", file, err)
		}

		if len(structs) > 0 {
			dir := filepath.Dir(file)
			packagesToGenerate[dir] = append(packagesToGenerate[dir], structs...)
		}
	}

	// Генерируем файлы reset.gen.go для каждого пакета.
	for pkgDir, structs := range packagesToGenerate {
		if err := generator.Generate(pkgDir, structs); err != nil {
			return fmt.Errorf("failed to generate reset file for %s: %w", pkgDir, err)
		}
		fmt.Printf("Generated reset.gen.go for package %s\n", pkgDir)
	}

	if len(packagesToGenerate) == 0 {
		fmt.Println("No structs with // generate:reset comment found")
	}

	return nil
}

// getZeroValue возвращает нулевое значение для примитивного типа.
//
// typeName — имя типа.
//
// Возвращает строковое представление нулевого значения или пустую строку, если тип не примитивный.
func getZeroValue(typeName string) string {
	switch typeName {
	case "int", "int8", "int16", "int32", "int64":
		return "0"
	case "uint", "uint8", "uint16", "uint32", "uint64", "uintptr":
		return "0"
	case "float32", "float64":
		return "0"
	case "complex64", "complex128":
		return "0"
	case "string":
		return `""`
	case "bool":
		return "false"
	case "byte":
		return "0"
	case "rune":
		return "0"
	default:
		return ""
	}
}

// ********************
// LITLE TRASH FUNCTION
// ********************

// formatType форматирует AST-узел типа в строку.
//
// expr — AST-узел типа.
//
// Возвращает строковое представление типа.
func formatType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", formatType(t.X), t.Sel.Name)
	case *ast.StarExpr:
		return "*" + formatType(t.X)
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + formatType(t.Elt)
		}
		return fmt.Sprintf("[%s]%s", formatType(t.Len), formatType(t.Elt))
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", formatType(t.Key), formatType(t.Value))
	default:
		return ""
	}
}


package sum

import "testing"

func TestSum(t *testing.T) {
    if sum := Sum(1, 2); sum != 3 {
        t.Errorf("sum expected to be 3; got %d", sum)
    }
} 